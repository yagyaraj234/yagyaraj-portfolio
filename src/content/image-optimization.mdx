export const metadata = {
  title: "How to Optimize Images for LCP & Web Performance",
  author: "Yagyaraj Lodhi",
  date: "2026-02-14",
  tags: [
    "image-optimization",
    "lcp",
    "web-performance",
    "core-web-vitals",
    "responsive-images",
    "lqip",
    "webp",
    "avif",
  ],
  ogImage: "https://yagyaraj.com/post/image-optimization/og.png",
  summary:
    "Learn production-grade image optimization techniques using LQIP, responsive images, pixel density, and LCP best practices.",
};

Hey üëã developers!

Images are usually the heaviest part of any modern web application.

- You can optimize JavaScript.
- You can split bundles.
- You can use CDN and edge caching.

But if your image is 2MB and blocks rendering, your **LCP is gone**.

<br />
And when LCP is slow, your Core Web Vitals suffer. When Core Web Vitals suffer,
rankings and conversions drop.
<br />
In most real-world apps, images are the **Largest Contentful Paint element**.
<br />
<br />
Let's break this properly and fix it the right way.

In this guide, we'll cover:

- How images impact **Largest Contentful Paint**
- How to optimize LCP images correctly
- LQIP (Low Quality Image Placeholder)
- Screen size‚Äìbased image delivery
- Pixel density (Retina) optimization
- Orientation-based images
- Modern formats (WebP, AVIF)
- Production-ready workflow
- Common mistakes developers make

This is practical, not theory.

---

## Understanding LCP and Why Images Destroy It

![LCP waterfall breakdown showing resource load timing in Chrome DevTools](https://images.openai.com/static-rsc-3/wQWUWuNR_0f0FshT5VmizytiBsU2NNX7CrLgy6OUGHR5_C7PgRJ3QQ13dz_NbtDWaa5SGtFYZrMda9dFP9eOHNwJFIpvHHWgKBRo5_sHqLI?purpose=fullsize&v=1)

![LCP timeline showing image download impact on largest contentful paint](https://images.openai.com/static-rsc-3/XzZYFJEZ1ns3rqOx-WDFH9kw_nfbothDvuZUdBYaOcBlYq7372EnXbOR5-XRndhhNjQxDPuAWuf2O4gilP4f6m3RTD39LoleHSUYXllgVWU?purpose=fullsize&v=1)

![Chrome DevTools highlighting the LCP element on a Shopify product page](https://performance.shopify.com/cdn/shop/files/devtools-lcp-element.png?width=760)

![LCP badge indicator in Chrome DevTools Performance Insights panel](https://developer.chrome.com/static/docs/devtools/performance-insights/image/the-lcp-badge-3d27cefbb1f8f.png)

**Largest Contentful Paint (LCP)** measures how long it takes for the largest visible element in the viewport to render.

In 70‚Äì80% of web apps, that element is:

- Hero banner image
- Product image
- Featured blog image
- Background promotional image

LCP is considered good if it loads under **2.5 seconds**.

But here's what most developers miss:

LCP is not just image download time.

It includes:

- Time to First Byte (TTFB)
- Resource discovery
- Download time
- Decoding time
- Rendering time

If your image is loaded via JavaScript or delayed behind heavy scripts, LCP will be bad even if the image is compressed.

---

## Step 1: Properly Prioritize the LCP Image

If your above-the-fold image is lazy-loaded, you already messed up.

### ‚ùå Wrong

```html
<img src="/hero.jpg" loading="lazy" />
```

Lazy loading delays LCP. That's correct for below-the-fold images ‚Äî not for hero images.

### ‚úÖ Correct Approach

Use preload + high priority:

```html
<link rel="preload" as="image" href="/hero.jpg" />
<img src="/hero.jpg" fetchpriority="high" alt="Hero" />
```

If you are using NextJS. You can use the NextJS `Image` component and pass the `priority` prop.

```jsx
<Image src="/hero.jpg" priority alt="Hero" />
```

This tells the browser:

> "This image is critical. Load it first."

That alone can reduce LCP by 300‚Äì800ms in many cases.

---

## Step 2: Implement LQIP (Low Quality Image Placeholder)

![LQIP comparison showing blurred placeholder transitioning to full quality image](https://cf-assets.www.cloudflare.com/zkvhlag99gkb/Mlb3C96uo4KLWgNe835l2/31ccbe118c20ce15f4c35c5ceb0cd377/image6.jpg)

LQIP stands for **Low Quality Image Placeholder**.

Instead of showing a blank box while the image loads, we:

- Show a tiny blurred version (10‚Äì20px wide)
- Or embed base64-encoded mini image
- Replace it once full image loads

### Why this matters

It improves:

- Perceived speed
- Visual stability
- User experience
- Layout stability

Even if your image takes 1.8 seconds, users see something instantly.

### Basic Example

```html
<img
  src="data:image/jpeg;base64,/9j/4AAQSk..."
  data-src="/real-image.jpg"
  class="blur"
/>
```

### Using NextJS `Image` component.

```jsx
<Image
  src="/hero.jpg"
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..."
/>
```

### When NOT to Use LQIP

- Small icons
- Images under 10kb
- Below-the-fold content
- Highly compressed thumbnails

Don't add complexity where it doesn't help.

---

## Step 3: Screen Size‚ÄìBased Image Optimization (Responsive Images)

Users are not using the same devices.

Mobile: 375px
Tablet: 768px
Desktop: 1440px+

Serving a 2000px image to mobile is waste.

### Use `srcset` and `sizes`

```html
<img
  src="image-800.jpg"
  srcset="image-400.jpg 400w, image-800.jpg 800w, image-1600.jpg 1600w"
  sizes="(max-width: 768px) 100vw, 50vw"
  alt="Product"
/>
```

Browser selects the smallest required image automatically.

This reduces:

- Mobile data usage
- Download time
- LCP
- Memory consumption

### Why This Is Critical

Without responsive images:

- Mobile downloads desktop-size image
- Wasted bandwidth
- Slower rendering
- Poor UX

Always generate multiple widths for production apps.

---

## Step 4: Pixel Density Optimization (Retina & High-DPI Screens)

Not all screens have the same pixel density.

Some devices have:

- devicePixelRatio = 1
- devicePixelRatio = 2
- devicePixelRatio = 3

If you serve only 1x images to 2x screens, images look blurry.

### Use Density Descriptors

```html
<img src="logo.jpg" srcset="logo.jpg 1x, logo@2x.jpg 2x" alt="Logo" />
```

Browser selects appropriate image based on pixel density.

### Important Rule

Never force 2x image for all users.

Let browser decide.

Otherwise you double file size unnecessarily.

---

## Step 5: Device Orientation Based Images

Sometimes cropping changes based on orientation.

Portrait mobile ‚Üí vertical image
Landscape desktop ‚Üí wide hero

Use `<picture>` element.

```html
<picture>
  <source media="(orientation: portrait)" srcset="portrait.jpg" />
  <source media="(orientation: landscape)" srcset="landscape.jpg" />
  <img src="landscape.jpg" alt="Hero" />
</picture>
```

Browser selects image based on orientation.

This is useful when:

- Composition changes
- Important subject needs cropping
- UI layout differs

Don't use this blindly. Use only when design demands it.

---

## Step 6: Modern Image Formats (WebP & AVIF)

Old JPEG and PNG are heavy.

Prefer:

- WebP
- AVIF

Benefits:

- 25‚Äì50% smaller
- Better compression
- Same visual quality

### Use Fallback Structure

```html
<picture>
  <source srcset="image.avif" type="image/avif" />
  <source srcset="image.webp" type="image/webp" />
  <img src="image.jpg" alt="Product" />
</picture>
```

Browser chooses best supported format.

Modern CDNs like:

- Cloudinary
- ImageKit
- Fastly Image Optimizer
- Next.js Image component

Can auto-convert formats.

---

## Step 7: Always Define Width & Height

Missing width and height causes layout shift.

That affects:

- CLS
- Visual stability
- User experience

Always define dimensions:

```html
<img src="image.jpg" width="800" height="600" alt="Product" />
```

Or use CSS aspect-ratio.

This prevents content jumping during load.

---

## Step 8: Avoid Using CSS Background for LCP Images

If your hero image is:

```css
.hero {
  background-image: url("/hero.jpg");
}
```

Browser may not prioritize it correctly.

Prefer `<img>` for critical images.

Use background-image only for decorative visuals.

---

## Real Production Workflow for Image Optimization

Here is how you should think in real apps.

### 1. Identify LCP Element

Use:

- Chrome DevTools
- Lighthouse
- Web Vitals extension
- PageSpeed Insights

Find exact LCP element.

### 2. Fix Loading Priority

- Remove lazy loading
- Add preload
- Add fetchpriority="high"
- Reduce JS blocking

### 3. Generate Variants

For critical images:

- 400w
- 800w
- 1200w
- 1600w
- 1x
- 2x
- WebP
- AVIF

Automate with build tools or CDN.

### 4. Implement LQIP Only for Critical Images

Don't add blur placeholders everywhere.

### 5. Monitor Real User Metrics

Lab data is not enough.

Track:

- Real LCP
- Real CLS
- Real FCP

Through analytics or RUM tools.

---

## Common Image Optimization Mistakes

1. Lazy loading hero image
2. Loading image after large JS bundle
3. Serving full-resolution images to all devices
4. No width/height attributes
5. Ignoring pixel density
6. Overusing LQIP
7. Using background-image for critical content

If your LCP image is injected via JavaScript after hydration, you're delaying it unnecessarily.

---

## When You Should NOT Over-Optimize

Don't:

- Generate 12 variants for tiny icons
- Use orientation-based switching for simple layouts
- Add LQIP for 5kb images
- Use AVIF if compatibility becomes a problem for your audience

Optimization should improve performance, not increase maintenance burden.

---

## Final Thoughts

Image optimization is not just compression.

It's about serving:

- The right size
- The right format
- At the right time
- To the right device

If your LCP image loads fast, your app feels fast.

And when your app feels fast, users stay.

That's the goal.

---

[linkedin](https://linkedin.com/in/yagyaraj234) | [github](https://github.com/yagyaraj234) | [twitter](https://x.com/yagyaraj234)
